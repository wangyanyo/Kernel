1. 一开始只是装载第一个扇区的内容到内存，想要装载其他扇区需要在第一个扇区的代码中使用0x13中断。可以用ghex查看boot.bin的二进制
    内容，这里面是实际被放到磁盘里的数据。但是real mode没有文件的概念，它只会加载boot.bin的第一扇区的内容并执行。
2. 写了一个引导进32位保护模式的代码，但这个代码我没太看懂，因为我对x86汇编不是特别熟。我想通过chatgpt深入了解一下这个代码是如何
    工作的。
3. 装了一个交叉编译器的环境
4. 修改Makefile，boot.bin占0号扇区，第1～100扇区(暂时)存放我们的内核代码。内核代码是由多个二进制文件链接而成，首先将各个文件
    编译成elf二进制格式，接着编写ld文件配置链接规则，即代码起始位置是1M，格式为二进制文件，代码最开始的命令是_start，以及各个
    段的位置和字节对齐设置。同时为了字节对齐，我们让kernel.asm的代码占512字节，这样多个二进制文件就能链接成内核代码了。然后向
    os.bin中写入boot.bin和kernel.bin，我们的操作系统就做好了。
    首先电脑和会将0号扇区加载到内存，在内存的0x7c00位置执行我们的boot程序，boot程序中定义了32位保护模式，它首先设置段寄存器，
    然后进入32位保护模式，然后将1～100扇区的内容加载到内存，然后跳转到CODE_SEG:0x100000，开始执行内核代码。在kernel.asm
    中要标注global _start便于链接，同时还有extern kernel_main和C语言程序链接，他首先设置段寄存器，然后设置a20(兼容设置)，
    然后就转向kernel_main()函数。
    链接的时候要打标记，要不然是没办法进行跨文件格式跳转的，ld文件也不知道一开始的标注到底是哪个，但是如果知道代码地址的话那直接
    跳转就可以了，那为什么C语言文件之间没有标注却可以跳转呢？因为C语言的头文件就是标注，在编译时会找到头文件对应函数的地址。综上
    所述，如果要使用其他文件的代码，就必须要提前标注，这样才好链接。
4. 写了一个向终端打印字符串的函数，终端会打印0xB800后面的字符串，因此我们只要将字符串提前放到这个位置上，终端就会自动打印出来。
      我还以为打印要用到中断什么的，但是仔细一想单纯的的打印并不用和键盘交互，只需要把对应的内存交给显卡处理即可。
      还有就是内核编程很底层，它没办法使用大部分的库函数，甚至不能识别\n。但是好处是自由度更高，内核完全是计算机的主人，可以随便使
    用内存，比如前面的0xB800，我只要uint16_t* vedio_mem = 0xB800即可，不用分配内存，随便读写，而且都是真实的地址。我们平常说
    的分配内存是操作系统分配的，而我们本身就是操作系统。
      显卡输出字符要看两个字节，第一个字节是字符，第二个字节是颜色。我们将这两个字节放到vedio_mem的对应位置，该字符就在终端对应
    位置上打印出来了。想要输出一个字符串，我们还要维护一个坐标，每输出一个字符就更新坐标，遇到\n直接把行加一，列置零。然后获取字符
    串的长度，将字符串的字符依次打印出即可。按照上面的逻辑，还可以处理一下\t，只要让列变成下一个4的倍数即可。
5. 增加了一个向量描述符表，有两个结构idt_desc代表中断函数的属性，idtr_desc里面是中断函数的数量和中断函数表的起始地址，他们都遵循
    一个规则。写出初始化中断函数表和设置中断函数的方法，调用idt_load将其装载，使用lidt利用idtr_desc内的信息将函数表装载。然后
    中断函数就被更新了，可以使用 div 0 来检验。
    磁盘分布
      0～0x200       boot
      0x200~0x1200   text
      0x1200~0x2200   rodata
      0x2200~0x3200   data
      0x3200~0x4200   bss
      0x4200~0x5200   asm
      其中 0x200~0x400 是kernel.asm，0x400~0x1200是其他内核代码

    内存分布
      0x7c000   boot程序
      0x100000  内核代码，_start
6. 增加了in和out的函数，原理是使用汇编的in和out，暂时不知道怎么用，我对IO端口不是很熟。
7. 增加了对硬件中断处理的函数，硬件中断指的是键盘，定时器，硬盘这些。首先将硬件中断重新映射到以0x20为起始的中断表上，接下来对所有
    中断设置一个默认的中断处理程序。然后对想要设置的中断进行处理，比如键盘中断就是 0x20 + 0x1 = 0x21，那么我们设置0x21的中断
    程序是int21h，在汇编中定义，为什么要跳到汇编来呢？因为我们要禁用中断，因为我们不想嵌套中断；我们要保存所有寄存器；我们要有
    iret来表示这是一个中断程序，执行中断才会有的ret操作。在int21h中再调用int21_handler，在C语言中定义，这样就实现了一个硬件
    中断处理函数。
      其实内核就是应该用汇编来写，只不过汇编太难理解，所以我们在必要的时候才会使用汇编。就像上面的中断程序，有些操作只能在汇编里做，
    所以跳到汇编里，但是函数主体很复杂，用汇编很难写，所以再跳回C。
8. 内存分配这里没做太多检查，要是分配溢出了，或者释放非法地址，或者多个线程都需要分配内存时该怎么办？而且分配内存的时候很慢，要遍历
    整个内存池找到连续的块，优化思路是搞一个空白块的链表，但是这样在访存和释放时又会有问题。
      加入了内存管理机制，在boot程序后面存储了我们的页信息表，页信息表达了该页是否被占用，是否是第一个，后面还有没有连续的页。每次
    分配内存就返回连续的free页并打上标记，释放内存就将标记改为free，这样的实现非常简单易懂，但是也有上面三个缺点，1. 没做检查
    2. 无法同时应对多个内存请求 3. 效率不高
      为什么需要内核来管理内存呢？内存管理+分页虚拟内存 共同组成了linux进程的安全机制，它们两个是密不可分的。同时由内核来分配内存
    也更加方便，在用户程序眼里电脑里只有自己这一个进程，并且拥有完成的4GB内存，不需要考虑进程切换，也不需要考虑内存分布，内核给
    进程营造了一个自由、安全的环境。而在内核眼里，我要不断响应中断处理任务调度，内存管理，设备驱动等工作，而且物理内存也只有一部
    分能使用，还有考虑溢出的问题。总之内核的机制对于在其上的应用程序来说是有很大用处的。
9. 在初始化阶段我们希望禁用中断，所以编写了两个汇编函数专门用于启用中断和禁用中断，在kernel.asm的一开始禁用中断，在kernel.c的
    初始化结束后调用汇编的启用中断函数来恢复中断。我们还希望在任何启用中断的时间段，中断描述符表里是有东西的，而之前的程序有一段
    空窗期。
10. 分页还可以设置一些权限等信息，将物理内存隐藏起来，用户程序不知道发生了什么，不知道其他进程的存在，可以获得更大的内存。我们可以
    隐藏我们的boot程序和内核程序。可以保护程序代码，比如我们把代码部分设置为只读。
      cr0和cr3寄存器用于分页相关。
      增加了paging模块，采用二级页表，1024*1024*4096。首先在分配4kb内存作为一级页表，然后遍历一级页表的每一个项，给其赋值二级
    页表的entry。由于分页，内存分配返回的地址的后12位都为0，因此我们可以用高20位来保存映射，低12位来设置一些flag，比如读写权限，
    是否有效等等。创建完页表后，我们还要把页表的地址赋给cr3，这样是加载页表。同时将cr0 | 0x80000000，这样是启用页表。在内核的
    初始化阶段，我们要为内核创建4GB的页表，内核也是需要页表的。
11. 新建了配置页表的函数，可以建立一个虚拟地址页到物理地址页的映射。首先我知道为什么之前初始化的时候创建了全部页表，并为每一个虚拟
    地址都建立了映射，并且该映射指向它本身，这是因为一旦启用分页，所有的访存都要经过页表，我们想让内核即使进入分页状态也能和之前一样
    访问物理内存。第二，分页对内核来说只是一个映射，我可以让任意一个页成为另一个页的映射，但是我们不会那么自由，我们一般是让任意一个
    页地址成为被分配的内存页的映射，感觉这个映射对于内核来说可有可无，意义不明。第三，分页主要服务于多进程，每个进程都有自己的页表，
    每次切换进程时我们把页表地址赋给cr3，然后将 cr0 | 0x80000000 -> cr0 启用分页，就实现了进程地址空间的切换，用户进程不会一下
    子创建所有列表，虽然在进程眼里自己拥有完整的4GB，但是有很多页其实是没有对应的物理页的，并且进程的所有页都是内核的heap分配的。
12. 增加了一个可以从磁盘读数据的函数disk_read_sector(), 第一个参数代表起始扇区，第二个参数代表扇区数，第三个参数代表缓存地址。
    其流程和boot程序里加载内核代码的流程相同，就是通过一些固定的in, out来实现读磁盘。
13. 写了一个读磁盘的驱动程序，disk结构体里存储了磁盘的编号以及扇区大小。使用disk_search_and_init()函数来初始化磁盘驱动，使用
    disk_get()函数来获取对硬磁盘的disk结构地址，使用disk_read_blocks()函数读磁盘，底层原理就是利用之前写的读磁盘程序。但是
    我们只有一个磁盘，因此没有search的功能，也没有区分对于不同的磁盘作不同的操作，但是我们还是写了这些抽象的函数，为了日后扩展。
14. 文件系统提供了一个读写磁盘的抽象，磁盘本身是不知道文件系统的存在的。如果没有文件系统，我们将被迫使用扇区号来读取和写入磁盘，这
    是我们不想看到的。(如何把一个机器变成一个方便且可用的操作系统)
      实现了FAT文件系统，文件系统可以说是内核的难点之一，也是内核的关键部分。教程里的是FAT16文件系统，这个系统不是最好的，但是相对
    简单，我的计划是首先写出FAT16，然后在未来一个月之内更新 内存管理 和 文件系统，我想写一个类似linux的 ETX4 文件系统。
      如何设计文件系统呢？首先要在脑子里有个大致的模型，我的这个文件系统的核心功能是什么？最核心的功能就是我能通过文件路径找到磁盘
    里对应的文件。那么首先要做的就是对路径字符串的处理，我要从路径字符串里获取所有我想要的信息，包括其是否合法，其驱动器号等等。这些
    功能函数可以在一开始写出来，也可以在接下来的开发中需要什么就些什么。那么“接下来的开发”是指什么呢？当然是我的文件本身，我的文件
    的struct结构是怎么表示的？在磁盘中是怎么表示的？在内存中是怎么表示的？我的打开文件，关闭文件，读写文件这些基础功能该如何实现？
    我们要把路径字符串转为路径链表，类似词法分析，接下来我们就不会再用路径字符串了。
      这个 current_directory_path 好像没用到啊，这是什么当前地址吗？那取驱动器号和取前面的地址不应该从这个做起吗？或者说一开始
    将两个字符串连在一起。
      写内核尽量不要使用递归，因为内核中没有保护机制，我们绝对不想看到栈溢出的情况，那会使计算机崩溃。
      add-symbol-file ../build/kernelfull.o 0x100000
      target remote | qemu-system-i386 -hda ./os.bin -S -gdb stdio
15. 创建分页时过慢，接下来解决这个问题。主要是kzalloc()的memset太慢，我将char换成int，一次赋值4个字节。经过这样的优化后，速度
    确实快了一些。但最让我不解的是为什么一个 1024 * 1024 的循环跑了1s的时间？是模拟器太慢了吗？我clone了原作者的代码，发现他也
    有这个问题。
16. 增加了disk streamer，其实就是记录了一个磁盘的定位，类似指针。可以读取该“指针”后面制定字节数的数据。底层没有实质性的改变，
    只是从磁盘读数据更方便了。以前是读出几个扇区的内容，然后抛弃掉多余的。比如我要读第一扇区的中间字节，那么我会先把第一扇区读出来，
    然后单独取出中间的字节。而现在要做的只是给一个定位和驱动器号，就可以想读多少字节就读多少，而且读的过程中指针一直在向后移动，就
    像一个“流”，但底层的实现是没变的，这只是一个抽象。
      遇到了一个bug，通过 “输出中间值 + 猜 + 粘贴原作者代码” 的方式找到了错误发生处。在idt.c的第42行
      错误代码：idtr_descriptor.limit = KERNEL_TOTAL_INTERRUPTS;
      正确代码：idtr_descriptor.limit = sizeof(idt_descriptors) -1;
      像这种一定要小心设置，因为这是固定的，类似公式的东西。
17. 在引导程序里增加了FAT16头，加上这个之后，linux就可以识别出我这个os.bin是一个文件系统，然后就可以把linux的一个文件夹挂载到
    我的内核程序上。FAT16头包含了一些文件系统的基本信息，比如一个扇区多少字节，一个集群多少扇区，多少个保留扇区等等，也是类似公式
    的东西，这个一定不能写错。
18. VFS是虚拟文件系统的意思，它是一层操作文件的抽象。在插入磁盘时，它会检测该磁盘的文件系统，然后将磁盘和对应的文件系统进行绑定，
    绑定方法是，内核里一开始就有各种文件系统的fopen, fread, fwrite, fclose等等这些函数的定义，然后我的disk结构里有几个函数
    指针，然后我让这些函数指针指向对应的函数，这样就是实现了绑定。同时我用户在调用fopen的时候，我的内核会创建一个file结构，里面
    有这个文件的信息和绑定的文件系统函数，并且返回这个file的index，也就是文件描述符。这样用户就可以用这个文件描述符来申请fread,
    fwrite, fclose这些操作。如果没有VFS，我们就只能用一种文件系统，非常不灵活，我们不想要过渡耦合的代码，通过加入VFS中间层 + 
    函数指针绑定的方式，实现了灵活且优美的文件系统。很多耦合问题都提议通过增加中间层来解决。
      使用函数指针绑定类似面向对象里的多态，其实C++的很多语法都可以通过C来实现。
19. 新增了VFS，VFS允许我们的内核可以处理多种文件系统。filesystem有若干函数指针，指向实现fopen,fread,fwrite,fclose...的具体
    实现，也就是说filesystem是一个接口，可以指向不同的实现。我们有一个filesystem数组，代表内核能处理的所有文件系统，我们可以用
    fs_init()在内核初始化的时候加载文件系统，也可以使用fs_insert_filesystem()加载文件系统。我们可以用fs_resolve()给磁盘绑定
    对应的文件系统。同时我们还可以获取一个文件描述符，或者使用文件描述符访问对应的文件。文件描述符里有index, disk 和 filesystem，
    我估计还要加一个 streamer。
      总之，VFS是一层灵活的抽象，它可以让我们的内核使用多个文件系统。
20. 新增了fat16文件系统的框架，以及其与VFS的对接。写完接口定义后，接下来我们就要开始写fopen, fread, fwrite, fclose, fstat的
    实现细节，这是文件系统最关键的部分。
21. 新增了fat16相关的结构，其中包含了fat16_header用于识别fat16文件系统，fat16_header_extended存储一些扩展信息,fat16_h代表
    一个完整的fat16头。fat_directory_item定义了文件的属性；fat_directory代表文件夹，相较于fat_directory_item要额外存储一
    些东西；fat_item代表文件项，它指向文件夹或文件，通过一个类型变量来识别。如果用户要打开文件，我们返回fat_item_descriptor，
    里面有指向fat_item的指针。对于该磁盘的fat16系统，我们持有一个fat_private，目前作用未知。
      在设计结构的时候需要经验，什么时候用指针，什么时候不用。用指针更节省空间，但也更麻烦，比如需要释放空间或者多个对象共用同一块
    空间等等。
      通过 指针 + union + 函数指针 可以实现所有的面向对象特性。
22. 新增了fs_resolve()的实现，fs_resolve()干两件事，第一件是检查该磁盘是不是自己这个文件系统，方式是检查第一个扇区的文件系统的
    部分的flag；第二件事是初始化fat_private并赋给磁盘，首先初始化header，直接读磁盘即可，然后初始化三个流，然后初始化root文件，
    就是把对应位置的数读出来，然后计算出item数量，初始扇区，结束扇区这些。
23. 新增了fopen的VFS层的处理，什么是打开文件，就是我们内核要获取这个文件的信息，然后返回一个文件描述符的index。所以我们解析路径，
    解析文件打开模式，获取磁盘，检查磁盘的文件系统，然后使用磁盘的绑定的文件系统的fopen(disk, path, mode)函数获取文件的信息，
    有了disk, disk->filesystem, private后，我们就可以新建一个文件描述符并将上面三个赋给它，然后返回该文件描述符的index。以上
    是通用的fopen的流程，接下来要实现具体的fat16的fopen流程，我猜fat16文件夹里的文件的fat_directory_item都是放在一起的，且
    大小固定，所以就像类似字典树那样向下搜索就能找到我们想要的文件。
24. fat_item_descriptor->pos 有什么用？
      标注了几个可能的错误和值得优化的地方，就连原作者都会出错，我这样的小白肯定也在某些地方出错了，只是测试不够，检查不够，所以还未
    显现出来罢了。所以说每做完一个模块就再重复检查一下，看看有没有错误或值得优化的点。
      等到该fat16写完，我会将我标注出来的地方都改好。
      fat的fopen就是返回一个fat_item，首先就是按照路径一层层获取fat_item，用过的fat_item要free，直到找到最后的文件。那么如何
    获取fat_item呢？首先遍历当前目录的每一个项，算出其文件名并比对，找出相同的文件名；然后制作fat_item，首先根据其文件类型来做出
    不同的fat_item，如果是普通文件，那么只需复制当前的fat_directory_item即可，如果是文件夹，还要载入其目录所有项；首先算出总项
    数，算出要读取的字节数，然后便开始读取；每次读取，根据starting_cluster和offset找出应该读取的cluster，然后找到对应的位置，
    找到后开始读取，offset+=total_to_read, out+=total_to_read, 然后进行下一次读取，最终将所有目录项全部读取。
      最终VFS获得了fat_item，我们成功新建了一个文件描述符，我们知道这个文件存在，也知道的它的disk, fs 和fat_firectory_item里
    的信息，我们可以使用这些信息进行读写。fopen帮我们找到这个文件，并提供这个文件的信息，它占用内存，也占用文件描述符。
25. 写了fread, 从VFS角度看就是做一些参数检查，并且调用对应文件系统的fread; 对于fat16, 我们做的就是使用fat16_read_internal()
    读取起点为starting_cluster, 位置为offset, 大小为size的数据，做nmemb次循环。我认为读完要更新pos, 但是原作者没更新。
      还有就是根目录的ending_sector_pos是有用的，它是cluster的起点，我通过检查ghex发现了这一点。