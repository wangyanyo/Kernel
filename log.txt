1. 一开始只是装载第一个扇区的内容到内存，想要装载其他扇区需要在第一个扇区的代码中使用0x13中断。可以用ghex查看boot.bin的二进制
    内容，这里面是实际被放到磁盘里的数据。但是real mode没有文件的概念，它只会加载boot.bin的第一扇区的内容并执行。
2. 写了一个引导进32位保护模式的代码，但这个代码我没太看懂，因为我对x86汇编不是特别熟。我想通过chatgpt深入了解一下这个代码是如何
    工作的。
3. 装了一个交叉编译器的环境
4. 修改Makefile，boot.bin占0号扇区，第1～100扇区(暂时)存放我们的内核代码。内核代码是由多个二进制文件链接而成，首先将各个文件
    编译成elf二进制格式，接着编写ld文件配置链接规则，即代码起始位置是1M，格式为二进制文件，代码最开始的命令是_start，以及各个
    段的位置和字节对齐设置。同时为了字节对齐，我们让kernel.asm的代码占512字节，这样多个二进制文件就能链接成内核代码了。然后向
    os.bin中写入boot.bin和kernel.bin，我们的操作系统就做好了。
    首先电脑和会将0号扇区加载到内存，在内存的0x7c00位置执行我们的boot程序，boot程序中定义了32位保护模式，它首先设置段寄存器，
    然后进入32位保护模式，然后将1～100扇区的内容加载到内存，然后跳转到CODE_SEG:0x100000，开始执行内核代码。在kernel.asm
    中要标注global _start便于链接，同时还有extern kernel_main和C语言程序链接，他首先设置段寄存器，然后设置a20(兼容设置)，
    然后就转向kernel_main()函数。
    链接的时候要打标记，要不然是没办法进行跨文件格式跳转的，ld文件也不知道一开始的标注到底是哪个，但是如果知道代码地址的话那直接
    跳转就可以了，那为什么C语言文件之间没有标注却可以跳转呢？因为C语言的头文件就是标注，在编译时会找到头文件对应函数的地址。综上
    所述，如果要使用其他文件的代码，就必须要提前标注，这样才好链接。
4. 写了一个向终端打印字符串的函数，终端会打印0xB800后面的字符串，因此我们只要将字符串提前放到这个位置上，终端就会自动打印出来。
      我还以为打印要用到中断什么的，但是仔细一想单纯的的打印并不用和键盘交互，只需要把对应的内存交给显卡处理即可。
      还有就是内核编程很底层，它没办法使用大部分的库函数，甚至不能识别\n。但是好处是自由度更高，内核完全是计算机的主人，可以随便使
    用内存，比如前面的0xB800，我只要uint16_t* vedio_mem = 0xB800即可，不用分配内存，随便读写，而且都是真实的地址。我们平常说
    的分配内存是操作系统分配的，而我们本身就是操作系统。
      显卡输出字符要看两个字节，第一个字节是字符，第二个字节是颜色。我们将这两个字节放到vedio_mem的对应位置，该字符就在终端对应
    位置上打印出来了。想要输出一个字符串，我们还要维护一个坐标，每输出一个字符就更新坐标，遇到\n直接把行加一，列置零。然后获取字符
    串的长度，将字符串的字符依次打印出即可。按照上面的逻辑，还可以处理一下\t，只要让列变成下一个4的倍数即可。
5. 增加了一个向量描述符表，有两个结构idt_desc代表中断函数的属性，idtr_desc里面是中断函数的数量和中断函数表的起始地址，他们都遵循
    一个规则。写出初始化中断函数表和设置中断函数的方法，调用idt_load将其装载，使用lidt利用idtr_desc内的信息将函数表装载。然后
    中断函数就被更新了，可以使用 div 0 来检验。
    磁盘分布
      0～0x200       boot
      0x200~0x1200   text
      0x1200~0x2200   rodata
      0x2200~0x3200   data
      0x3200~0x4200   bss
      0x4200~0x5200   asm
      其中 0x200~0x400 是kernel.asm，0x400~0x1200是其他内核代码

    内存分布
      0x7c000   boot程序
      0x100000  内核代码，_start
6. 增加了in和out的函数，原理是使用汇编的in和out，暂时不知道怎么用，我对IO端口不是很熟。
7. 增加了对硬件中断处理的函数，硬件中断指的是键盘，定时器，硬盘这些。首先将硬件中断重新映射到以0x20为起始的中断表上，接下来对所有
    中断设置一个默认的中断处理程序。然后对想要设置的中断进行处理，比如键盘中断就是 0x20 + 0x1 = 0x21，那么我们设置0x21的中断
    程序是int21h，在汇编中定义，为什么要跳到汇编来呢？因为我们要禁用中断，因为我们不想嵌套中断；我们要保存所有寄存器；我们要有
    iret来表示这是一个中断程序，执行中断才会有的ret操作。在int21h中再调用int21_handler，在C语言中定义，这样就实现了一个硬件
    中断处理函数。
      其实内核就是应该用汇编来写，只不过汇编太难理解，所以我们在必要的时候才会使用汇编。就像上面的中断程序，有些操作只能在汇编里做，
    所以跳到汇编里，但是函数主体很复杂，用汇编很难写，所以再跳回C。
8. 内存分配这里没做太多检查，要是分配溢出了，或者释放非法地址，或者多个线程都需要分配内存时该怎么办？而且分配内存的时候很慢，要遍历
    整个内存池找到连续的块，优化思路是搞一个空白块的链表，但是这样在访存和释放时又会有问题。
      加入了内存管理机制，在boot程序后面存储了我们的页信息表，页信息表达了该页是否被占用，是否是第一个，后面还有没有连续的页。每次
    分配内存就返回连续的free页并打上标记，释放内存就将标记改为free，这样的实现非常简单易懂，但是也有上面三个缺点，1. 没做检查
    2. 无法同时应对多个内存请求 3. 效率不高
      为什么需要内核来管理内存呢？内存管理+分页虚拟内存 共同组成了linux进程的安全机制，它们两个是密不可分的。同时由内核来分配内存
    也更加方便，在用户程序眼里电脑里只有自己这一个进程，并且拥有完成的4GB内存，不需要考虑进程切换，也不需要考虑内存分布，内核给
    进程营造了一个自由、安全的环境。而在内核眼里，我要不断响应中断处理任务调度，内存管理，设备驱动等工作，而且物理内存也只有一部
    分能使用，还有考虑溢出的问题。总之内核的机制对于在其上的应用程序来说是有很大用处的。
9. 在初始化阶段我们希望禁用中断，所以编写了两个汇编函数专门用于启用中断和禁用中断，在kernel.asm的一开始禁用中断，在kernel.c的
    初始化结束后调用汇编的启用中断函数来恢复中断。我们还希望在任何启用中断的时间段，中断描述符表里是有东西的，而之前的程序有一段
    空窗期。
10. 分页还可以设置一些权限等信息，将物理内存隐藏起来，用户程序不知道发生了什么，不知道其他进程的存在，可以获得更大的内存。我们可以
    隐藏我们的boot程序和内核程序。可以保护程序代码，比如我们把代码部分设置为只读。
      cr0和cr3寄存器用于分页相关。
      增加了paging模块，采用二级页表，1024*1024*4096。首先在分配4kb内存作为一级页表，然后遍历一级页表的每一个项，给其赋值二级
    页表的entry。由于分页，内存分配返回的地址的后12位都为0，因此我们可以用高20位来保存映射，低12位来设置一些flag，比如读写权限，
    是否有效等等。创建完页表后，我们还要把页表的地址赋给cr3，这样是加载页表。同时将cr0 | 0x80000000，这样是启用页表。在内核的
    初始化阶段，我们要为内核创建4GB的页表，内核也是需要页表的。
11. 新建了配置页表的函数，可以建立一个虚拟地址页到物理地址页的映射。首先我知道为什么之前初始化的时候创建了全部页表，并为每一个虚拟
    地址都建立了映射，并且该映射指向它本身，这是因为一旦启用分页，所有的访存都要经过页表，我们想让内核即使进入分页状态也能和之前一样
    访问物理内存。第二，分页对内核来说只是一个映射，我可以让任意一个页成为另一个页的映射，但是我们不会那么自由，我们一般是让任意一个
    页地址成为被分配的内存页的映射，感觉这个映射对于内核来说可有可无，意义不明。第三，分页主要服务于多进程，每个进程都有自己的页表，
    每次切换进程时我们把页表地址赋给cr3，然后将 cr0 | 0x80000000 -> cr0 启用分页，就实现了进程地址空间的切换，用户进程不会一下
    子创建所有列表，虽然在进程眼里自己拥有完整的4GB，但是有很多页其实是没有对应的物理页的，并且进程的所有页都是内核的heap分配的。
12. 增加了一个可以从磁盘读数据的函数disk_read_sector(), 第一个参数代表起始扇区，第二个参数代表扇区数，第三个参数代表缓存地址。
    其流程和boot程序里加载内核代码的流程相同，就是通过一些固定的in, out来实现读磁盘。
13. 写了一个读磁盘的驱动程序，disk结构体里存储了磁盘的编号以及扇区大小。使用disk_search_and_init()函数来初始化磁盘驱动，使用
    disk_get()函数来获取对硬磁盘的disk结构地址，使用disk_read_blocks()函数读磁盘，底层原理就是利用之前写的读磁盘程序。但是
    我们只有一个磁盘，因此没有search的功能，也没有区分对于不同的磁盘作不同的操作，但是我们还是写了这些抽象的函数，为了日后扩展。
14. 文件系统提供了一个读写磁盘的抽象，磁盘本身是不知道文件系统的存在的。如果没有文件系统，我们将被迫使用扇区号来读取和写入磁盘，这
    是我们不想看到的。(如何把一个机器变成一个方便且可用的操作系统)
      实现了FAT文件系统，文件系统可以说是内核的难点之一，也是内核的关键部分。教程里的是FAT16文件系统，这个系统不是最好的，但是相对
    简单，我的计划是首先写出FAT16，然后在未来一个月之内更新 内存管理 和 文件系统，我想写一个类似linux的 ETX4 文件系统。
      如何设计文件系统呢？首先要在脑子里有个大致的模型，我的这个文件系统的核心功能是什么？最核心的功能就是我能通过文件路径找到磁盘
    里对应的文件。那么首先要做的就是对路径字符串的处理，我要从路径字符串里获取所有我想要的信息，包括其是否合法，其驱动器号等等。这些
    功能函数可以在一开始写出来，也可以在接下来的开发中需要什么就些什么。那么“接下来的开发”是指什么呢？当然是我的文件本身，我的文件
    的struct结构是怎么表示的？在磁盘中是怎么表示的？在内存中是怎么表示的？我的打开文件，关闭文件，读写文件这些基础功能该如何实现？
    我们要把路径字符串转为路径链表，类似词法分析，接下来我们就不会再用路径字符串了。
      这个 current_directory_path 好像没用到啊，这是什么当前地址吗？那取驱动器号和取前面的地址不应该从这个做起吗？或者说一开始
    将两个字符串连在一起。
      写内核尽量不要使用递归，因为内核中没有保护机制，我们绝对不想看到栈溢出的情况，那会使计算机崩溃。
      add-symbol-file ../build/kernelfull.o 0x100000
      target remote | qemu-system-i386 -hda ./os.bin -S -gdb stdio
15. 创建分页时过慢，接下来解决这个问题。主要是kzalloc()的memset太慢，我将char换成int，一次赋值4个字节。经过这样的优化后，速度
    确实快了一些。但最让我不解的是为什么一个 1024 * 1024 的循环跑了1s的时间？是模拟器太慢了吗？我clone了原作者的代码，发现他也
    有这个问题。
16. 增加了disk streamer，其实就是记录了一个磁盘的定位，类似指针。可以读取该“指针”后面制定字节数的数据。底层没有实质性的改变，
    只是从磁盘读数据更方便了。以前是读出几个扇区的内容，然后抛弃掉多余的。比如我要读第一扇区的中间字节，那么我会先把第一扇区读出来，
    然后单独取出中间的字节。而现在要做的只是给一个定位和驱动器号，就可以想读多少字节就读多少，而且读的过程中指针一直在向后移动，就
    像一个“流”，但底层的实现是没变的，这只是一个抽象。
      遇到了一个bug，通过 “输出中间值 + 猜 + 粘贴原作者代码” 的方式找到了错误发生处。在idt.c的第42行
      错误代码：idtr_descriptor.limit = KERNEL_TOTAL_INTERRUPTS;
      正确代码：idtr_descriptor.limit = sizeof(idt_descriptors) -1;
      像这种一定要小心设置，因为这是固定的，类似公式的东西。
17. 在引导程序里增加了FAT16头，加上这个之后，linux就可以识别出我这个os.bin是一个文件系统，然后就可以把linux的一个文件夹挂载到
    我的内核程序上。FAT16头包含了一些文件系统的基本信息，比如一个扇区多少字节，一个集群多少扇区，多少个保留扇区等等，也是类似公式
    的东西，这个一定不能写错。
18. VFS是虚拟文件系统的意思，它是一层操作文件的抽象。在插入磁盘时，它会检测该磁盘的文件系统，然后将磁盘和对应的文件系统进行绑定，
    绑定方法是，内核里一开始就有各种文件系统的fopen, fread, fwrite, fclose等等这些函数的定义，然后我的disk结构里有几个函数
    指针，然后我让这些函数指针指向对应的函数，这样就是实现了绑定。同时我用户在调用fopen的时候，我的内核会创建一个file结构，里面
    有这个文件的信息和绑定的文件系统函数，并且返回这个file的index，也就是文件描述符。这样用户就可以用这个文件描述符来申请fread,
    fwrite, fclose这些操作。如果没有VFS，我们就只能用一种文件系统，非常不灵活，我们不想要过渡耦合的代码，通过加入VFS中间层 + 
    函数指针绑定的方式，实现了灵活且优美的文件系统。很多耦合问题都提议通过增加中间层来解决。
      使用函数指针绑定类似面向对象里的多态，其实C++的很多语法都可以通过C来实现。
19. 新增了VFS，VFS允许我们的内核可以处理多种文件系统。filesystem有若干函数指针，指向实现fopen,fread,fwrite,fclose...的具体
    实现，也就是说filesystem是一个接口，可以指向不同的实现。我们有一个filesystem数组，代表内核能处理的所有文件系统，我们可以用
    fs_init()在内核初始化的时候加载文件系统，也可以使用fs_insert_filesystem()加载文件系统。我们可以用fs_resolve()给磁盘绑定
    对应的文件系统。同时我们还可以获取一个文件描述符，或者使用文件描述符访问对应的文件。文件描述符里有index, disk 和 filesystem，
    我估计还要加一个 streamer。
      总之，VFS是一层灵活的抽象，它可以让我们的内核使用多个文件系统。
20. 新增了fat16文件系统的框架，以及其与VFS的对接。写完接口定义后，接下来我们就要开始写fopen, fread, fwrite, fclose, fstat的
    实现细节，这是文件系统最关键的部分。
21. 新增了fat16相关的结构，其中包含了fat16_header用于识别fat16文件系统，fat16_header_extended存储一些扩展信息,fat16_h代表
    一个完整的fat16头。fat_directory_item定义了文件的属性；fat_directory代表文件夹，相较于fat_directory_item要额外存储一
    些东西；fat_item代表文件项，它指向文件夹或文件，通过一个类型变量来识别。如果用户要打开文件，我们返回fat_item_descriptor，
    里面有指向fat_item的指针。对于该磁盘的fat16系统，我们持有一个fat_private，目前作用未知。
      在设计结构的时候需要经验，什么时候用指针，什么时候不用。用指针更节省空间，但也更麻烦，比如需要释放空间或者多个对象共用同一块
    空间等等。
      通过 指针 + union + 函数指针 可以实现所有的面向对象特性。
22. 新增了fs_resolve()的实现，fs_resolve()干两件事，第一件是检查该磁盘是不是自己这个文件系统，方式是检查第一个扇区的文件系统的
    部分的flag；第二件事是初始化fat_private并赋给磁盘，首先初始化header，直接读磁盘即可，然后初始化三个流，然后初始化root文件，
    就是把对应位置的数读出来，然后计算出item数量，初始扇区，结束扇区这些。
23. 新增了fopen的VFS层的处理，什么是打开文件，就是我们内核要获取这个文件的信息，然后返回一个文件描述符的index。所以我们解析路径，
    解析文件打开模式，获取磁盘，检查磁盘的文件系统，然后使用磁盘的绑定的文件系统的fopen(disk, path, mode)函数获取文件的信息，
    有了disk, disk->filesystem, private后，我们就可以新建一个文件描述符并将上面三个赋给它，然后返回该文件描述符的index。以上
    是通用的fopen的流程，接下来要实现具体的fat16的fopen流程，我猜fat16文件夹里的文件的fat_directory_item都是放在一起的，且
    大小固定，所以就像类似字典树那样向下搜索就能找到我们想要的文件。
24. fat_item_descriptor->pos 有什么用？
      标注了几个可能的错误和值得优化的地方，就连原作者都会出错，我这样的小白肯定也在某些地方出错了，只是测试不够，检查不够，所以还未
    显现出来罢了。所以说每做完一个模块就再重复检查一下，看看有没有错误或值得优化的点。
      等到该fat16写完，我会将我标注出来的地方都改好。
      fat的fopen就是返回一个fat_item，首先就是按照路径一层层获取fat_item，用过的fat_item要free，直到找到最后的文件。那么如何
    获取fat_item呢？首先遍历当前目录的每一个项，算出其文件名并比对，找出相同的文件名；然后制作fat_item，首先根据其文件类型来做出
    不同的fat_item，如果是普通文件，那么只需复制当前的fat_directory_item即可，如果是文件夹，还要载入其目录所有项；首先算出总项
    数，算出要读取的字节数，然后便开始读取；每次读取，根据starting_cluster和offset找出应该读取的cluster，然后找到对应的位置，
    找到后开始读取，offset+=total_to_read, out+=total_to_read, 然后进行下一次读取，最终将所有目录项全部读取。
      最终VFS获得了fat_item，我们成功新建了一个文件描述符，我们知道这个文件存在，也知道的它的disk, fs 和fat_firectory_item里
    的信息，我们可以使用这些信息进行读写。fopen帮我们找到这个文件，并提供这个文件的信息，它占用内存，也占用文件描述符。
25. 写了fread, 从VFS角度看就是做一些参数检查，并且调用对应文件系统的fread; 对于fat16, 我们做的就是使用fat16_read_internal()
    读取起点为starting_cluster, 位置为offset, 大小为size的数据，做nmemb次循环。我认为读完要更新pos, 但是原作者没更新。
      还有就是根目录的ending_sector_pos是有用的，它是cluster的起点，我通过检查ghex发现了这一点。
26. 新增了fseek，其实就是修改pos的值，文件描述符记录了文件的所有信息，除了文件内容。
27. 函数指针 + void* private 实现了继承和多态。函数指针实现了虚函数，void* private 实现了子类的独有成员。也就是说可以将一个类
    配置成完全不同的版本，函数指针指向该版本的函数，void* private 指向该版本独有的数据成员。
28. 增加了fstat，他返回文件的状态，比如是不是只读，是不是可执行的等；还返回文件的大小。我们使用 ls -l 命令时就会调用fstat。
29. User land 用户态能实现的最基本的条件是处理器的四个等级，ring 0, ring 1, ring 2, ring 3，User land 位于 ring 3，在
    ring 3 等级很多指令时没办法执行的，比如更改中断描述符表，更换页表，以及直接访问硬件的 in 或 out 指令，这就使得User land没
    办法修改内核的中断函数，没办法主动切换到其他进程，没办法直接访问硬件；以上再加上内存分配和页表，限制了User land对内存的访问，
    这样就使得用户进程是安全的，它没办法直接访问硬件，没办法随意访问内存，没办法影响内核的状态，没办法影响其他进程。
      用户进程不是特殊的进程，无论是用户进程还是内核进程都是同样的结构，即Task。User land只是描述了执行用户进程时处理器的状态，
    此时处理器限制等级是ring 3, 页表是当前进程的页表。这是User land的本质。
      我们切换进程时，只是切换页表和寄存器，切换页表也只是将页表的地址赋给cr3，并不是什么很费时间的操作。甚至多个进程可以有共享内存，
    只要让页表映射到同一位置即可。
      其实中断这里和gdt这里不太明白，gdt是切换到保护模式用的，这里还是不太理解，当时只是在照做，这个gdt究竟有什么用呢？为什么切换
    到保护模式就需要这个gdt呢？我记得实模式是16位的，当时想切换到32位所以进入了保护模式，这里还要再学习一下。
      又看了一遍这节课，很多东西伏羲了一下，也了解到了很多新的东西，但还有一点我不明白。那就是“假装从中断返回“是什么意思？这么做有
    什么意义？
      GDT和IDT那里还是不熟悉，需要看一下osdev和重新梳理一下代码。我这个习惯很不好，不熟悉的东西应该马上把它搞明白，而不是直接跳过，
    就算不精通也可以，但至少要知道“这个东西是干什么的？”，“如果没有这个东西会怎么样？”，“这个东西和其他模块的联系“ 
      我还想重新梳理一下整个程序，要把每个地方都搞懂，把每个模块的逻辑搞清楚，其中有些模块有问题，还要总结一下。
30. 用C语言实现了设置并加载GDT的操作，课程中说GDT是来描述地址空间的，难道这个也和User land有关吗？想知道这些，首先还是要彻底搞懂
    gdt是什么。
      还有就是我的项目开发的效率还有转化率不高，看课->总结->自己动手写->对照修改->下一步的展望，想试一下这个流程，感觉如果能在45分
    钟内一气呵成做完的话，效率和转化率都会很高，但考虑到一节课就将近20分钟，感觉需要两个学习段才能做完。
      看完10页CSAPP就做项目，每天三次贡献，重复上面的流程，大概需要5个小时。做完这些我还想看osdev，每天看三个主题。然后我想看
    Linux内核分析与实现，每天看10页。
      约束自己，高效学习，合理制定计划，保持精力。优先解决各种生理问题，然后再考虑其他的。
      买个坐垫，多喝水，多睡觉，每隔45分钟就活动15分钟，吃饭细嚼慢咽，不要打胶。让自己进入一个正向的循环。
31. 我大概理解GDT的用处了，GDT是用来描述一个段的。CSAPP有介绍过，x86架构默认使用分段，但是Linux想用纯粹的分页，这个要怎么实现呢？
    很简单，不论是代码段还是数据段，我都让他们的起始位置为0x00，Size为0xffffffff，这样就构建了一个不用分段，纯粹分页的32位地址
    空间，也就是说x86的 Protected Mode 的访存，默认先分段，后分页，我们把一个段扩充至整个地址空间，那么就只有分页了。这也是我们设
    置GDT的原因，因为访存时要先访问GDT，GDT的位置存在gdtr里，偏移量存在ltr里。
      这就是知识的串联，我终于搞懂GDT是什么东西了，这源于我在各方面学习的知识串联起来的结果，就像吹一个长气球，一下子肯定吹不出来，
    但是我可以一点一点吹出其中一小段，然后把他们串联起来，这样气球就好吹了。
      但是还有一处不解，那就是那个type有什么用？想搞懂这一点还是要看osdev。 
    增加了tss，即Task Switch Segment，具体作用未知，里面存储了大部分的寄存器信息，好像是用于恢复内和执行状态用的，总之是和进程
    切换相关。创建完tss结构后，还要编写tss_load()函数，实际上是设置ltr内的偏移量。然后我们要在kernel.c中创建tss，并将其放入到
    GDT中，而且GDT中还要新增用户代码段和用户数据段。
      难道说，所有的用户进程都要有一个对应的tss吗？是这样的。Intel的CPU提供了任务切换的功能。
      每个进程都有一个TSS，ltr里存储的是当前进程的TSS在GDT表里的偏移量，因为前面有5个GDT entry，因此新增的这个TSS的偏移量就是
    40, 新增的这个TSS描述的是内核进程。
      使用TSS来进行任务切换是Intel给我们的便利，只需一个命令就可以完成任务切换(只需写回当前TSS，加载目标TSS)，但是时间较长，一次
    切换要花费200周期且移植性差，不能在其他厂商的芯片上运行。现在的OS都是通过切换堆栈的方式完成任务切换，这也是我未来的更新目标。
32. 增加了task模块，task是一个链表结构，增加了新建，删除，返回下一个任务，返回当前任务的函数，可以说是建了一个task的框架。但是还有
    一些问题，我记录在 warning 中了，待修改。并且原作者的链表删除函数有bug，我将其修改了。如果在头文件中少加分号的话会出现莫名其妙
    的大量错误，特此记录。
33. 意识到了一个问题，那就是如果日后要更新内存管理，并将其修改成不连续的申请内存。那就有很多地方都要改，因为在内核代码中申请完空间
    没有建立内存映射, 因此在内核代码看来申请的空间是不连续的, 而用户态由于有页表映射，所以没有这个问题。那是不是说内核必须申请连续
    的空间, 而用户程序则无所谓呢? 日后更新内存管理的时候要考虑到这一点.
      新增了process，主要流程就是把二进制文件读出来，然后进行内存映射和寄存器设置，内存映射是paging_map_to(), task_init()设置
    了寄存器的初始值。令我疑惑的是，目前用户栈既没有映射，也没有赋值给栈寄存器。
      还有一个让我疑惑的点就是config.h中设置的栈地址是0x3ff000，小于0x400000，我怀疑这个是内核栈，但是内核空间不是在高地址空间
    吗？还是说内核栈是特殊的，它就是在低地址空间，.text之前的？
      没什么好说的，补充上次的代码，有几个原作者有错误的点，日后要多加留意。
34. 我终于搞懂哪个0x23和0x1b是干什么的了，这个0x23是0x20 + 3, 0x20是因为user data segment的gdt是第5个，所以偏移量是0x20
    因为gdt的偏移量是8的倍数，所以低三位都是0，所以用低两位来存储CPL，user land的CPL是3，所以是0x20 + 3 = 0x23
      看了最新版本的代码，有几个确实是作者写的有问题，但是它并没有全都改好，我还发现了另外几个错误。之后我要把他们写到issue里。
      我们想要从内核态进入用户态，什么时候会出现这样的转变呢？我们注意到中断返回时计算机会从内核态切换到用户态。所以我们初始化完内核
    后，我们伪造一个中断返回，我们向栈中push对应的用户态的上下文(其中包含用户态的页表, gdt, CPL等)，然后使用iretd进行中断返回，
    这样我们就从内核态进入用户态了。
35. 写了一个无限循环的用户程序，主要工作在于链接和写make文件。
    i686-elf-gcc -g -T ./linker.ld -o ./blank.bin -ffreestanding -O0 -nostdlib -fpic -g ./build/blank.o
    cd ./programs/blank && $(MAKE) all
    上面这两句有点疑惑，第一个为什么已经生成可执行文件了但还是要再链接一次？第二个后面的 && 和 $(MAKE) 没看懂，这是make的语法
    吗？还要再学一下make。
36. 现在我们要做的就是加载第一个进程。过程是调用process_load()，它创建并初始化process结构，并将其放入进程表中，同时还会创建一个
    task, task中的主要内容有页表、registers，registers里面有通用寄存器，段寄存器，栈指针，ip等。process_load()还会加载可执
    行程序到内存中，virt对应0x400000，pyhs对应process->ptr，建立内存映射。也就是说process_load之后，页表准备好了，程序进入
    内存了，task页准备好了。接下来就是加载task并进入user_land，方式是伪造一个中断返回，假设当前处于中断中，先更新页表，然后将
    一些特殊寄存器压到栈里，然后设置通用寄存器，然后执行中断返回，这样我们就进入了user_land，并开始执行我们写的用户程序。

    请时刻注意，我们开发的并不是linux内核，它只是一个能实现基础功能的内核。为了教学方便，它的很多模块采用的低效、古老但是简单的实现
    方法。我的计划是通过写完这个最基础的版本作为我内核的入门，并且完全理解这个版本，在此版本的基础上将核心功能一步步向Linux靠拢。
    因此在遇到该项目中的实现方法与Linux不同时，不要焦虑，要意识到这个版本只是最基础的内核。要思考该版本的不足之处，并思考Linux的
    机制是如何实现的，不要混淆。

      就比如，kernel的加载是将可执行文件加载到内存，然后建立映射，然后加载页表，然后将该程序的上下文推到栈中或加载到寄存器中，然后中
    断返回，这样就完成了一个程序的加载；而Linux的加载则不同，它会先建立一个区域映射，哪个区域对应哪个文件的哪个部分，然后同样也是将
    进程的上下文推入栈中或加载到寄存器，然后中断返回，运行时再按需分配页面。
      还有kernel的process_load()包含了创建进程，创建页表，创建任务，以及加载可执行文件，可以说是把所有的工作都包揽了；
      而Linux则分成了两步，fork()和exec()，fork()用于创建一个新进程，它会复制父进程的页表，分配一个新的pid，用写时复制技术保证
    父子进程的隔离性。exec()负责建立区域映射，将区域映射到对应的文件，同时设置一些标志位来表示这些区域的状态，然后具体的物理页面时
    按需分配的，即访问到时才会从磁盘中加载出来。
      同样是从内核态进入用户态并运行可执行文件。两个内核的执行过程不同，Linux的机制肯定是更优秀的，注意辨别，不要混淆。虽然该内核
    的机制不如Linux，但是同样实现了目的，这便是好的，但是未来还是要向Linux不断靠拢。

      即使这是一个最基础版本的内核，但是它的一些细节还是让我不太理解，比如刚才就发现一个bug，直接导致我的模拟器一直死机重启。
    错误代码：
      tss.esp = 0x600000;
      tss.ss = KERNEL_DATA_SELECTOR;
    正确代码：
      tss.esp0 = 0x600000;
      tss.ss0 = KERNEL_DATA_SELECTOR;
    esp0和ss0好像是分别代表内核栈和内核数据段，我把他们改成esp和ss就导致模拟器死机。这说明我对这些底层的东西不是很熟悉，那唯一的
    办法就是重新梳理代码并学习osdev上的知识。
      而且遇到问题不要跳过，要重复观看课程或重复翻阅书本，并且在网上找对应的解答。不要带着一个模糊的概念往下学习，起码要有一个清晰的
    印象。
37. 接下来是从用户态进入内核态，通过trap(原作者说是中断，我觉得不精确)进入内核态。之前我们中断返回的时候将task中存储的寄存器推到
    栈里，然后执行iretd中断返回进入User Land，但是那是我们伪造的中断返回。而这次我们是由用户态进入内核态再返回该进程的的用户态，
    所以我们再进入内核态的第一时间就把当前寄存器值压入栈中，然后中断函数执行结束后，将这些栈中的寄存器值放回去，iretd回到用户态。
      还有注册函数，这是在我网络编程后第二次接触注册函数，我很好奇注册函数做了什么。其实就是设置一个函数指针数组，让我们可以用数组
    的格式去调用与数字相关联的函数(比如中断号)，这样我们就不用使用复杂的函数名，使代码更加简洁。
      感觉 task_get_stack_item 有点问题，页表之间的转换有点绕，而且他把一个栈顶的元素解释成了 void*，我不能理解。
      void *task_get_stack_item(struct task* task, int index)
      {
        void *result = 0;
        ASSERT(is_kernel_page());
        uint32_t *sp_ptr = (uint32_t *)task->registers.esp;
        task_page_task(task);
        result = (void *)sp_ptr[index];
        kernel_page();
        return result;
      }
      先是在内核页表下获得了esp的值，然后切到用户页表，然后将栈的第index个元素的值转成void*并赋给result, 然后切回内核页表，返回
      result。我猜esp应该指向的是用户栈，要不然没必要切回到用户态，然后得到用户栈的第index值后，他把这个值再转成void*是我不能理
      解的，从函数名上来说应该是获取栈中的元素，但是为什么要翻译成void*呢？切回内核页表时可以理解的，因为这个函数就是在内核态执行
      的。 
38. 我终于知道 push ebp
             mov ebp, esp 的目的是什么了，就是为了访问参数。正常来说栈中先是参数，然后是栈指针，虽然可以通过esp加一个偏移量访问
    到这些参数，但是esp是变化的，这就增加了编译器的复杂性，所以我们选择通过edp来访问参数，所以在函数一开始我们保存原来的ebp，将esp
    赋给ebp，接下来都通过ebp来访问参数，最后 pop ebp。
      ss 是 stack segment 的意思，是栈段的寄存器，在kernel中是数据段的偏移量+CPL，kernel是忽略栈寻址的。
    这一节写的是系统调用的处理函数，首先pushad将当前用户程序的状态压到栈里；然后切换到内核态：将段寄存器切换到内核数据段gdt偏移量，
    然后加载内核页表；接着保存用户态状态：把栈里的寄存器赋给current_task->registers, 其实就给进程一个独占处理器的幻觉，它察觉不
    到自己被中断了；然后根据commnd进行分流，执行对应的处理程序；最后加载用户数据段寄存器偏移量，加载用户页表，popad，iretd返回
    current_task的用户态。
39. 中断号不够用怎么办？原作者的方法是系统调用触发的都是0x80中断号，然后将具体的commnd标识放到eax里，通过这样一个二级操作，就避免
    了在遥远的未来可能会出现的中断号不够的情况。
      系统调用其实就是两条线，加上一些后期的补丁连接，第一条线是调用，即在用户程序中执行int 80h，然后控制权跳到80h绑定的isr80h_
    wapper()函数，在该函数里进入内核态，执行command对应的操作，然后返回用户态恢复控制权；第二条线就是在kernel初始化的时候就绑定
    command编号和对应的系统调用操作；后期的补丁就是后期加上新的系统调用并注册。
40. [debug 日志]
      系统调用出了一点问题，看上去就是我在一直重复的执行系统调用，但是我的用户程序只申请了一次。
      并不是内核重启，如果是的话，屏幕会频繁的闪烁。
      我想试试不依靠原作者的程序，单靠我对kernel的理解，能不能找到这个bug。
      好吧，我是sb，用户程序那里应该是 jmp $，而我写的是 jmp label，这样就是一个循环。
      label:
        mov eax, 0
        int 0x80
        jmp $
      运行gdb
        add-symbol-file ../build/kernelfull.o
        break *0x400000
        target remote | qemu-system-i386 -hda ./os.bin -S -gdb stdio
        c
        layout asm
        stepi
        ...
        通过上面的步骤，证明了我这个程序是运行无误的，最起码是真正执行了系统调用。
41. 现在想将用户空间的一个字符串复制到内核空间，由于二者拥有不同的页表，地址不互通，所以这件事没有那么容易。首先申请一个页空间tmp,
    然后定位用户空间内不包含virtual的一个页addr(默认为tmp), 然后找到用户空间内addr对应的old_entry, 然后将addr映射到tmp, 将
    virtual的字符串复制到tmp, 然后加载内核页表(因为只有在内核页表内才能设置用户空间的页表)，然后将addr的映射恢复到old_entry,
    最后将tmp的字符串复制到phys, 释放tmp。
      新建了一个paging_get, 用于获取对应页表的对应地址的entry.    
      这一节也有许多小问题。
42. 增加了打印字符串的系统调用，框架搭好了，都是用的之前的东西。但是还有一个问题，我的学习历程太不连贯了，导致我现在对这个项目逐渐
    不熟，虽然很多概念搞懂了，但是知识体系没有很好构建出来，这一点之后要注意。以后每天看三节课，课课总结；而且这只是初期的kernel，
    以后还会继续扩展，在那个时候再接着搭建知识体系。
43. 学习了读取键盘输入的课程，每按一次键盘都会触发一次中断，对应 0x1, 在我们的中断表中就是 0x21。触发中断的同时会有一个scancode,
    我们根据这个scancode找出对应的ascii码。每个进程都有一个keyborad结构，其中包含一个循环队列，由其中的head和tail维护。每次
    push对应的进程是我们当前的进程，每次pop对应的进程是正在运行的进程，push和pop是分开的，中断处理函数应该push之后就结束，但是我
    不知道这个pop是什么时候触发的。同时和VFS一样，我们还要编写一个虚拟键盘层，以便兼容更多键盘类型，比如鼠标点击的键盘，自动键盘，
    或者不同厂商的键盘。
44. 新增了keyboard_init()，用于初始化各种厂商的keyboard。创建了keyboard类型，该类型是一个链表结构，里面包含了名字和init函数，
    估计keyboard_init()初始化keyboard, 绑定init函数，然后向这个链表添加节点。
      添加了keyborad的push, pop 和 backspace, process有一个keyboard_buffer结构，里面是一个循环队列。由于键盘输入的字符的
    ascii码不会是0, 依据这一特性可以很轻松的判断队列是空还是满，所以push, pop 和 backspace 也都很简单。这一还有一个技术，就是
    head 和 tail 递增时不会进行模运算，而是等到真正用到时再模运算，算出在队列数组的真实位置，我以前没这样做过，这样在数学上来讲是
    没问题的，降低了编码难度，再加上队列里不会出现0的特性，能够轻松的判断溢出，最终使这个循环队列简单又准确。
45. 在makefile上犯了点小错误，在下面增加了编译指令，但是没在FILS里加入相应的可重定向文件，下次注意。
    这一章增加了ps2键盘的keyboard结构，并在其init函数中启用ps2。然后将该结构加到keyboard链表里。然后增加了scancode转换ascii码
    的函数，接下来还有几个问题，第一个就是处理键盘中断，第二是设置一个大小写状态，第三就是怎么区分正在显示的进程和正在运行的任务。第
    四就是什么时候pop。
      但是原作者要更新一下中断处理模块，以便于实现键盘功能，我很好奇他会更新什么。
46. 利用汇编宏预写出512个中断入口函数，然后经过处理后转到interrupt_handler中统一处理，0x80是特殊的。通过编译宏预写，简化了代码，
    增强了可读性；通过统一处理，使代码更有条理，看起来不那么乱，而且更方便。
47. 32号中断
      32号中断即0x20, 是定时器中断。
    add-symbol-file filename address
      该指令用于添加可重定向文件的符号表，后面是可重定向文件名以及该文件被加载的初始地址，可以用于辅助打断点。如果没有该符号表，那么
      在gdb里 break kernel.c:100 是不合法的，因为没有符号表和address就找不到kernel.c的位置，也找不到第100行的位置，但是
      break 0x400000 是合法的，当PC为0x400000，程序就暂停执行。
    什么是io port, io port和网络端口的区别，进程间沟通也要用到端口，这三者的区别。
    键盘模块的完整设计思路。
      
48. 该节用于实验
    实验一: 当cpu处于内核态会响应定时器中断吗？
      实验步骤: 注册完中断之后启用中断，然后执行一个无限循环。
        idt_register_interrupt_callback(0x20, pic_timer_callback);
        enable_interrupts();
        while(1){}
      预期结果: 如果在内核态可以响应定时器中断，那么在屏幕上会打印东西。
      实验结果:1.屏幕打印No current task, 我怀疑是有响应中断的
              2.我在idt.c的interrupt_handler()截断，输出interrupt
              3.成功运行，屏幕上无限打印32，说明在内核态成功响应了定时器中断
      总结: 1.是否响应中断和CPU状态无关，只与当前是否启用中断有关，即cli
            2. 如果执行完中断后不执行outb(0x20, 0x20), 那CPU将不再响应中断

    实验二: 通过gdb探究从用户程序执行一个系统调用的全过程
      实验步骤：我们关注其中几个寄存器
        1. 在blank.asm的第一句, 我们查看寄存器，其中:
          esp   0x3ff000
          eip   0x400000
          cs    0x1b
          ss    0x23
          ds    0x23
          es    0x23
          fs    0x23
          gs    0x23
          cr0   0x80000011  [ PG ET PE]
          cr3   0x1413000
        2. 在 int 0x80 之前，我们查看寄存器，其中:
          esp   0x3feffc
          eip   0x40000a
          cs    0x1b
          ss... 0x23
          cr0   0x80000011
          cr3   0x1413000
        3. 在 int 0x80 之后，我们查看寄存器，其中:
          esp   0x5fffec    这是我们设置的内核栈的位置，tss.esp0 = 0x600000
          eip   0x10500f    boot将内核程序加载到0x100000起始的位置，在用户程序中，该位置的页表是线性映射的，因此可以安全地跳转
                            到该位置，同时因为中断调用，esp变成tss里设置的内核栈的位置，cs和ss等段寄存器指向了内核段，因此拥有
                            了跳转到该位置的权限。(内核的esp存在哪未知，可能就在tss里？)
          cs    0x8
          ss... 0x10
          cr3   0x1413000
        4. 调用kernel_page()前，我们查看寄存器，其中:
          esp   0x5fffa4
          eip   0x1012eb
          cs    0x8
          ss... 0x10
          cr3   0x1413000
        5. 调用paging_load_directory()后，我们查看寄存器，其中: 
          esp   0x5fff64
          eip   0x101b22
          cs    0x8
          ss... 0x10
          cr3   0x1004000     可以看到页表更新为内核页表，可以线性且随意访问内存了
        6. 调用task_page_task()前, 我们查看寄存器, 其中:
            背景: 中断的参数在用户栈里, 我们把它取出来
          esp   0x5ffb04
          eip   0x10446d
          cs    0x8
          ss... 0x10
          cr3   0x1004000
        7. 调用task_page_task()前, 我们查看寄存器, 其中:
          esp   0x5ffb04      这里的栈指针仍然指向内核栈, 我们是要从用户栈里取数据, 用户栈的地址可以从task结构中获取
          eip   0x5ffb04
          cs    0x8
          ss    0x10
          ds... 0x23          ss仍然是内核数据段, 但是ds,es,fs,gs指向是用户数据段, ss是stack segment, 因为esp仍然指向
                              内核栈, ss仍然是内核数据段?
          cr3   0x1413000     可以看到现在是用户页表
          在执行完task_page_task()之后, 我们仍然要用到内核栈，如下:
            mov    0x24(%esp),%eax    index -> eax
            lea    0x0(,%eax,4),%edx  index*4 -> edx
            mov    0x8(%esp),%eax     sp_ptr -> eax
            add    %edx,%eax          sp_ptr + index*4 -> eax
            mov    (%eax),%eax        (eax) -> eax
            mov    %eax,0xc(%esp)     eax -> result
          可以看到，sp_ptr和index都被存储在内核栈中，所以我们的esp和ss要保留内核态。我们先用内核栈的数据算出用户栈参数的地址，然
          后访存，由于我们访问的是用户栈，所以要提前将页表设置为用户页表。访问用户栈不代表更新esp，我们可以在内核栈的基础上算出地址，
          然后在用户页表的基础上访存从而得到用户栈的数据。
            内核代码地址空间:
            ----------0x100000----------
            内核代码，数据
            ----------------------------
            内核栈
            ----------0x600000----------

            用户代码地址空间: 虚拟地址
            ----------0x000000----------
            ----------------------------
            用户栈                       -> 对应物理地址内存池的一块内存，但是这个栈的位置有点奇怪，它是在低地址空间
            ----------0x3ff000----------
            ----------0x400000----------
            用户代码，数据，堆             -> 对应物理地址内存池的一块内存
            ----------------------------

        8. 调用kernel_page()后，我们查看寄存器，其中:
          esp   0x5ffb14
          eip   0x104491
          cs    0x8
          ss... 0x10
          cr3   0x1004000     这里又回到了内核页表
        
        由上面的实验其实就能了解中断、以及内核用户态的转换究竟发生了什么，内核态和用户态是很灵活的，并没有很严格的界限，最重要的五个
        寄存器就是esp, eip, cs, ss..., cr0和cr3寄存器用于分页相关。
          明天还想看一下中断返回究竟发生了什么，以及在用户页表基础下跳到内核代码时，究竟发生了什么，是碰巧正确运行的吗？
49. keyboard被设置成一个系统调用，将keyboard_pop()包装成一个系统调用，那pop就是一个事件驱动，而不是循环。
      还有就是我的键盘不是ps2啊，为什么这个scancode还是准确的?
      现在已经能更加熟练的使用gdb了，打印寄存器是print $eax，但是还是不知道怎么layout源码。调试的时候应该有个调试的思路。
50. 实现了putchar函数，本质上是系统调用，跳到terminal_writechar函数，把字符打印到屏幕上这种和硬件交互的工作，确实应该交给内核来
    做，包装成系统调用没问题。但是，据我所知，输入输出不是和stdin和stdout有关吗？从stdin中读取，然后再输出到stdout。在该程序中从
    键盘中读取，再输出到屏幕上，难道说是把键盘看作stdin，把屏幕看作stdout？还是说应该在加一个中间层？即: 
            键盘 -> stdin -> user_tmp -> stdout -> 屏幕
    看看在之后的课程有没有其他输入输出函数吧

待办: 
    1. 中断返回发生了什么?
    2. 用户页表基础下跳到内核代码时，发生了什么?
    3. 阅读sem_wait()和sem_post()的源码
    4. 重看88的gdb调试部分，调试键盘的同时学习gdb
