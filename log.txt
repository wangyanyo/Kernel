1. 一开始只是装载第一个扇区的内容到内存，想要装载其他扇区需要在第一个扇区的代码中使用0x13中断。可以用ghex查看boot.bin的二进制
    内容，这里面是实际被放到磁盘里的数据。但是real mode没有文件的概念，它只会加载boot.bin的第一扇区的内容并执行。
2. 写了一个引导进32位保护模式的代码，但这个代码我没太看懂，因为我对x86汇编不是特别熟。我想通过chatgpt深入了解一下这个代码是如何
    工作的。
3. 装了一个交叉编译器的环境
4. 修改Makefile，boot.bin占0号扇区，第1～100扇区(暂时)存放我们的内核代码。内核代码是由多个二进制文件链接而成，首先将各个文件
    编译成elf二进制格式，接着编写ld文件配置链接规则，即代码起始位置是1M，格式为二进制文件，代码最开始的命令是_start，以及各个
    段的位置和字节对齐设置。同时为了字节对齐，我们让kernel.asm的代码占512字节，这样多个二进制文件就能链接成内核代码了。然后向
    os.bin中写入boot.bin和kernel.bin，我们的操作系统就做好了。
    首先电脑和会将0号扇区加载到内存，在内存的0x7c00位置执行我们的boot程序，boot程序中定义了32位保护模式，它首先设置段寄存器，
    然后进入32位保护模式，然后将1～100扇区的内容加载到内存，然后跳转到CODE_SEG:0x100000，开始执行内核代码。在kernel.asm
    中要标注global _start便于链接，同时还有extern kernel_main和C语言程序链接，他首先设置段寄存器，然后设置a20(兼容设置)，
    然后就转向kernel_main()函数。
    链接的时候要打标记，要不然是没办法进行跨文件格式跳转的，ld文件也不知道一开始的标注到底是哪个，但是如果知道代码地址的话那直接
    跳转就可以了，那为什么C语言文件之间没有标注却可以跳转呢？因为C语言的头文件就是标注，在编译时会找到头文件对应函数的地址。综上
    所述，如果要使用其他文件的代码，就必须要提前标注，这样才好链接。
4. 写了一个向终端打印字符串的函数，终端会打印0xB800后面的字符串，因此我们只要将字符串提前放到这个位置上，终端就会自动打印出来。
      我还以为打印要用到中断什么的，但是仔细一想单纯的的打印并不用和键盘交互，只需要把对应的内存交给显卡处理即可。
      还有就是内核编程很底层，它没办法使用大部分的库函数，甚至不能识别\n。但是好处是自由度更高，内核完全是计算机的主人，可以随便使
    用内存，比如前面的0xB800，我只要uint16_t* vedio_mem = 0xB800即可，不用分配内存，随便读写，而且都是真实的地址。我们平常说
    的分配内存是操作系统分配的，而我们本身就是操作系统。
      显卡输出字符要看两个字节，第一个字节是字符，第二个字节是颜色。我们将这两个字节放到vedio_mem的对应位置，该字符就在终端对应
    位置上打印出来了。想要输出一个字符串，我们还要维护一个坐标，每输出一个字符就更新坐标，遇到\n直接把行加一，列置零。然后获取字符
    串的长度，将字符串的字符依次打印出即可。按照上面的逻辑，还可以处理一下\t，只要让列变成下一个4的倍数即可。
5. 增加了一个向量描述符表，有两个结构idt_desc代表中断函数的属性，idtr_desc里面是中断函数的数量和中断函数表的起始地址，他们都遵循
    一个规则。写出初始化中断函数表和设置中断函数的方法，调用idt_load将其装载，使用lidt利用idtr_desc内的信息将函数表装载。然后
    中断函数就被更新了，可以使用 div 0 来检验。
    磁盘分布
      0～0x200       boot
      0x200~0x1200   text
      0x1200~0x2200   rodata
      0x2200~0x3200   data
      0x3200~0x4200   bss
      0x4200~0x5200   asm
      其中 0x200~0x400 是kernel.asm，0x400~0x1200是其他内核代码

    内存分布
      0x7c000   boot程序
      0x100000  内核代码，_start
6. 增加了in和out的函数，原理是使用汇编的in和out，暂时不知道怎么用，我对IO端口不是很熟。
